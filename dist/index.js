// @bun
import{randomBytes as w}from"crypto";var{CryptoHasher:_,file:z,gunzipSync:f,gzipSync:y,write:V}=globalThis.Bun;import{promises as m,mkdirSync as c,writeFileSync as o}from"fs";import{sign as F,verify as v}from"jsonwebtoken";var S=(Y)=>Array.from({length:Y},(Z,$)=>$);var s=S(10).join(""),t=new RegExp(/(\d+)(\d*)/,"m");var A=Object.values;var{entries:T,hasOwn:a}=Object;var b=Object.assign,I=(Y)=>{return Object.keys(Y).length};var J=(Y)=>{return Buffer.from(Y)},O=(...Y)=>{let Z=new Bun.CryptoHasher("sha256",N());return Y.forEach(($)=>{Z.update($)}),Z.digest()};var N=()=>{let Y=process.env.SECRET_KEY;if(!Y)throw new Error("'SECRET_KEY' not found in .env file");return Y};class q{date;constructor(Y){this.date=Y?new Date(Y):new Date}delta(Y=null,Z=!1){let $=q.delta(this.date.getTime(),Y);return Z?new Date($):$}timed(Y){let Z=this.date.getTime(),$=this.date;if(Y){let{year:U,month:W,day:Q,hour:K,minute:B,second:P}=Y;if(U)$=new Date($.setFullYear($.getFullYear()+U));if(W)$=new Date($.setMonth($.getMonth()+W));if(Q)$=new Date($.setDate($.getDate()+Q));if(K)$=new Date($.setHours($.getHours()+K));if(B)$=new Date($.setMinutes($.getMinutes()+B));if(P)$=new Date($.setSeconds($.getSeconds()+P))}return $}static delta(Y,Z=null){if(Z)return Z-Y;else return Y-Date.now()}static get now(){return Date.now()}}function G(Y){let Z=new _("md5");return Z.update(Y),Z.digest("hex")}var h=new TextDecoder,p={cookie:(Y,Z="",{maxAge:$,expires:U,path:W,domain:Q,secure:K,httpOnly:B,sameSite:P})=>{if($ instanceof Date)$=$.getSeconds();if(U instanceof Date)U=U.toUTCString();else if(U===0)U=new Date().toUTCString();return[["Domain",Q],["Expires",U],["Max-Age",$],["Secure",K],["HttpOnly",B],["Path",W],["SameSite",P]].reduce((j,[L,M])=>{if(M!==void 0)j.push(`${L}=${M}`);return j},[`${Y}=${Z}`]).join("; ")}},R={file:(Y,Z)=>{try{o(Y,Z??"",{flag:"wx"})}catch($){}return!0},dir:(Y)=>{return c(Y,{recursive:!0}),!0},decode(Y){return h.decode(Y)}};function n(Y=64){return new _("sha256").update(w(Y)).digest("hex")}class l{postgresClient;config={COOKIE_NAME:"session",COOKIE_DOMAIN:"127.0.0.1",COOKIE_PATH:"/",COOKIE_HTTPONLY:!0,COOKIE_SECURE:!0,REFRESH_EACH_REQUEST:!1,COOKIE_SAMESITE:"Strict",KEY_PREFIX:"session:",PERMANENT:!0,USE_SIGNER:!1,ID_LENGTH:32,FILE_THRESHOLD:500,LIFETIME:31,MAX_COOKIE_SIZE:4093,INTERFACE:"fs",STORAGE:".sessions",JWT_STORAGE:".jwt",JWT_LIFETIME:5};constructor({type:Y="fs",dir:Z}={}){Y&&(this.config.INTERFACE=Y),Z&&this.initStorage(Z)}initStorage(Y){return this.config.STORAGE=Y+"/"+this.config.STORAGE,this.config.JWT_STORAGE=Y+"/"+this.config.JWT_STORAGE,this}get session(){return new X(this.config,this.config.STORAGE)}get jwt(){return new X(this.config,this.config.JWT_STORAGE)}}class u{data;modified;new=!0;length=0;constructor(Y={}){if(this.modified=!0,this.data={},this.length=I(Y),this.length)this.new=!1;b(this.data,Y)}set(Y,Z,$){if(!this.readonly&&Y.data[Z]!=$){if(this.modified=!0,!(Z in Y.data))this.length++;return Y.data[Z]=$,!0}return!1}get(Y,Z){if(Z in Y)return Y[Z];return Y.data[Z]}has(Y,Z){if(Z in Y.data)return!0;return!1}deleteProperty(Y,Z){if(!this.readonly&&Z in Y.data)this.modified=!0,delete Y.data[Z],this.length--;return!0}}class E extends u{Y;modified;readOnly;constructor(Y="",Z={},$=!1){super(Z);this.sid=Y;this.modified=!1,this.readOnly=$}get session(){return new Proxy(this,this)}}class D{Y;constructor(Y){this.salt=Y}getSignature(Y){let Z=this.deriveKey().toString();return O(Z,Y).toString("base64")}deriveKey(){return O(this.salt)}sign(Y){let Z=this.getSignature(Y),$=J(Y+"."+Z);return R.decode($)}unsign(Y){if(!(Y.indexOf(".")>-1))throw Error("No sep found");let Z=Y.indexOf("."),$=Y.slice(0,Z),U=Y.slice(Z+1);return this.verifySignature($,U)}loadUnsign(Y){if(this.unsign(Y)){let Z=J(Y),$=J(".").toString()[0];if(!($ in Z))throw Error("No sep found");let U=Z.indexOf($),W=Z.subarray(0,U);return Buffer.from(W.toString(),"base64").toString("utf-8")}}verifySignature(Y,Z){return this.getSignature(Y)==Z?!0:!1}}class C{signer;constructor(Y){this.signer=new D(Y)}generate(Y=21){let $=w(Y).toString("base64");if($.endsWith("="))$=$.slice(0,-1);return this.signer.sign($)}}class x extends C{Y;constructor(Y,Z){super(Z??"salty");this.config=Y}async openSession(Y,Z){if(Y&&this.signer.unsign(Y))return await this.fetchSession(Y,Z);return this.new}async fetchSession(Y,Z){return this.new}async saveSession(Y,Z,$=!1){return}get new(){return new E(this.generate(),{}).session}get readonly(){return new E(this.generate(),{},!0).session}get getExpiration(){let Y=new Date,Z=this.config.LIFETIME;return Y.setDate(Y.getDate()+Z).toString()}setCookie(Y,Z,$=""){let U=null,W={};if(this.config.COOKIE_SAMESITE)U=this.config.COOKIE_SAMESITE;if($)U=$;if(Z===0)W.maxAge=Z.toString();else W.expires=Z;return p.cookie(this.config.COOKIE_NAME,Y.sid,{domain:"",path:this.config.COOKIE_PATH,httpOnly:this.config.COOKIE_HTTPONLY,secure:this.config.COOKIE_SECURE,sameSite:U,...W})}async loadHeader(Y,Z){let $=async(W)=>{let Q="";if(W)Q=W.split(";").reduce((P,H)=>{let[j,L]=H.trim().split(/=(.*)/s);return P[j]=L,P},{}).session;let K=Q;return await this.openSession(K,Z)},U=Y.headers;if(U){if("get"in U)return await $(U.get("cookie"));else if("cookie"in U)return await $(U.cookie)}return this.new}}class k extends E{}class g{path;data;constructor(Y){this.data=new Map,this.path=Y+"/"}async init(Y){let Z=G(Y),$=this.path+Z,U=z($);if(await U.exists()){let W=await U.arrayBuffer();try{let Q=JSON.parse(R.decode(f(W)));return Q.f_timed=Date.now(),this.data.set(Z,Q),Q}catch(Q){}}return null}async checkLast(Y){let Z=new Date(Y);if(Z.setMinutes(Z.getMinutes()+60),Z.getTime()<Date.now())return!0;return!1}async get(Y){if(Y){let Z=this.data.get(Y);if(Z==null)return await this.init(Y);else{if(Z&&"f_timed"in Z){if(await this.checkLast(Z.f_timed))return await this.init(Y)}return Z}}return null}async set(Y,Z){let $=G(Y),U=this.path+$;R.file(U,""),await V(U,y(JSON.stringify(Z))),Z.f_timed=Date.now(),this.data.set(Y,Z)}async delete(Y){let Z=G(Y);this.data.delete(Z);let $=this.path+Z;z($).exists().then(async(U)=>{await m.unlink($)}).catch()}}class X extends x{$;cacher;side=k;constructor(Y,Z=".sessions",$=!1){super(Y);this.isJWT=$;this.cacher=new g(Z)}life(Y,Z){let{LIFETIME:$,JWT_LIFETIME:U}=this.config;if(new q(Z).timed({day:this.isJWT?U:$}).getTime()-new Date().getTime()>0)return!0;else return this.cacher.delete(Y),!1}async fetchSession(Y,Z){let $=this.config.KEY_PREFIX+Y,U=await this.cacher.get($),W={};if(U){let Q=!0;if("life"in U)Q=this.life($,U.life);W=Q?JSON.parse(U.data):{}}return new this.side(Y,W,Z).session}async saveSession(Y,Z,$=!1){let U=(Q)=>{if(Z){let K=this.setCookie(Y,Q);if(Z)Z.set("Set-Cookie",K)}},W=this.config.KEY_PREFIX+Y.sid;if(!Y.length){if(!Y.new&&(Y.modified||$))this.cacher.delete(W),U(0);return}if(Y.new&&Y.modified){let Q=new q().timed({day:this.config.LIFETIME}),K=JSON.stringify(Y.data);await this.cacher.set(W,{data:K,life:q.now}),U(Q)}return}}class i{client;query;f_timed;data;key;constructor(Y,Z,$){this.query=$,this.key=Z,this.f_timed=Date.now(),this.data=new Map,this.client=Y}async init(Y){let Z=await this.client.query({text:this.query+` where ${this.key} = $1`,values:[Y]});for(let[$,U]of this.data)if(!U)this.data.delete($);if(Z.rowCount){let $=Z.rows[0];return $.f_timed=Date.now(),this.data.set(Y,$),$}else return this.data.set(Y,null),null}async checkLast(Y){let Z=new Date(Y);if(Z.setMinutes(Z.getMinutes()+15),Z.getTime()<Date.now())return!0;return!1}async get(Y){if(Y){let Z=this.data.get(Y);if(Z==null)return await this.init(Y);else{if(Z&&"f_timed"in Z){if(await this.checkLast(Z.f_timed))return await this.init(Y)}return Z}}return null}async set(Y){if(this.key in Y)Y.f_timed=Date.now(),this.data.set(Y[this.key],Y)}async delete(Y){this.data.delete(Y)}}class d extends C{salt;constructor(){super("salty_jwt");this.salt="salty_jwt"}sign(Y){let Z={issuer:this.salt};return F({data:Y},N(),Z)}get random(){let Y={issuer:this.salt},Z={data:n()};return F(Z,N(),Y)}jwt(){let Y=this.generate();return new E(Y).session}verify(Y,Z){try{let $=v(Y,N());if($){let{data:U,iat:W,iss:Q}=$;if(Q==this.salt)if(Z){let{days:K,hours:B,minutes:P,seconds:H}=Z,j=new Date(W*1000);if(K)j=new Date(j.setDate(j.getDate()+K));else if(B)j=new Date(j.setHours(j.getHours()+B));else if(P)j=new Date(j.setMinutes(j.getMinutes()+P));else if(H)j=new Date(j.setSeconds(j.getSeconds()+H));if(j.getTime()-Date.now()>0)return U}else return U}}catch($){}return null}open(Y,Z){if(Y){let $=this.verify(Y,Z);if($)return new E(Y,$,!0).session}return this.jwt()}save(Y){let Z=Y.data;if("access_token"in Z)delete Z.access_token;return this.sign(Z)}new(Y){return this.sign(Y)}}class r{fs;f_timed;data;key;dir;constructor({dir:Y,fs:Z,key:$}){this.dir=Y+"/ffs",this.key=$,this.f_timed=Date.now(),this.data=new Map,this.fs=this.dir+`/${Z}.json`}async init(){if(R.dir(this.dir)&&R.file(this.fs,"{}"))z(this.fs).text().then((Y)=>{let Z=JSON.parse(Y);this.data=new Map(T(Z))}).catch((Y)=>{})}async get(Y){let Z=this.data.get(Y);if(Z)return Z;return null}async set(Y){if(this.key in Y){let Z=await z(this.fs).text();if(Z){let $=JSON.parse(Z),U=Y[this.key];$[U]=Y,await V(this.fs,JSON.stringify($))}this.data.set(Y[this.key],Y)}}async delete(Y){if(await this.get(Y)){let Z=await z(this.fs).text();if(Z){let $=JSON.parse(Z.toString());if(Y in $)delete $[Y],await V(this.fs,JSON.stringify($));this.data.delete(Y)}}}async json(){let Y=await z(this.fs).text(),Z=JSON.parse(Y);return A(Z)}}export{G as decodeSID,E as ServerSide,i as PGCache,d as JWTInterface,r as Fjson,k as FSession,x as AuthInterface,l as Auth};
